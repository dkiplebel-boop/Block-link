<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Link</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap');
        
        /* --- Default Theme Variables (Dark Mode) --- */
        :root {
            --bg-primary: #1e1e2d;
            --bg-secondary: #0a0a1a;
            --ui-background: #282a36;
            --ui-panel: #383a59;
            --color-main: #fff;
            --color-accent: #bd93f9;
            --color-link: #ff79c6;
            --color-success: #50fa7b;
            --color-warning: #F8E71C;
            --color-canvas-bg: #282a36;
            --color-grid-line: #383a59;
            --color-button-primary: #bd93f9;
            --color-button-primary-shadow: #8a70b4;
            --color-button-primary-hover: #e6a9f8;
            --color-button-secondary: #ff79c6;
            --color-button-secondary-shadow: #ad437f;
            --color-button-secondary-hover: #ff99cc;
            --color-button-menu-bg: #4b5563; /* Gray-600 */
            --color-button-menu-shadow: #1f2937; /* Gray-800 */
        }

        /* Theme definitions */
        .theme-light { --bg-primary: #f0f0f5; --bg-secondary: #e0e0e5; --ui-background: #ffffff; --ui-panel: #f0f0f0; --color-main: #333; --color-accent: #9013FE; --color-link: #D0021B; --color-success: #1E824C; --color-warning: #C70039; --color-canvas-bg: #f8f8f8; --color-grid-line: #ccc; --color-button-primary: #9013FE; --color-button-primary-shadow: #5a0a9e; --color-button-primary-hover: #a948fe; --color-button-secondary: #D0021B; --color-button-secondary-shadow: #9e0214; --color-button-secondary-hover: #ff3349; --color-button-menu-bg: #9ca3af; --color-button-menu-shadow: #6b7280; }
        .theme-forest { --bg-primary: #1a3424; --bg-secondary: #0a1c12; --ui-background: #2d4a34; --ui-panel: #3a6042; --color-main: #e0f0e0; --color-accent: #7cb448; --color-link: #F5A623; --color-success: #b8cc9a; --color-warning: #EEDD4C; --color-canvas-bg: #2d4a34; --color-grid-line: #1e3a24; --color-button-primary: #7cb448; --color-button-primary-shadow: #4a7824; --color-button-primary-hover: #9cd468; --color-button-secondary: #F5A623; --color-button-secondary-shadow: #b3730e; --color-button-secondary-hover: #ffd378; --color-button-menu-bg: #5a7d61; --color-button-menu-shadow: #3f5e43; }
        .theme-upside-down { --bg-primary: #120a0a; --bg-secondary: #000000; --ui-background: #1a0f0f; --ui-panel: #2e1d1d; --color-main: #e0e0e0; --color-accent: #e50914; --color-link: #ff4545; --color-success: #ff0000; --color-warning: #ffe000; --color-canvas-bg: #1a0f0f; --color-grid-line: #331f1f; --color-button-primary: #e50914; --color-button-primary-shadow: #96060c; --color-button-primary-hover: #ff333d; --color-button-secondary: #ff4545; --color-button-secondary-shadow: #b22d2d; --color-button-secondary-hover: #ff6666; --color-button-menu-bg: #4d2626; --color-button-menu-shadow: #331a1a; }
        .theme-ocean { --bg-primary: #3a506b; --bg-secondary: #0e1e30; --ui-background: #6a8ba7; --ui-panel: #839aa8; --color-main: #f0f8ff; --color-accent: #00bcd4; --color-link: #ffcd3c; --color-success: #4caf50; --color-warning: #f44336; --color-canvas-bg: #6a8ba7; --color-grid-line: #4e6c87; --color-button-primary: #00bcd4; --color-button-primary-shadow: #008ba3; --color-button-primary-hover: #33e5ff; --color-button-secondary: #ffcd3c; --color-button-secondary-shadow: #c79c16; --color-button-secondary-hover: #ffeb8d; --color-button-menu-bg: #4682b4; --color-button-menu-shadow: #2c5374; }
        .toggle-switch { width: 50px; height: 25px; background: #ccc; border-radius: 25px; position: relative; cursor: pointer; transition: background-color 0.3s; }
        .toggle-switch.active { background: var(--color-success); }
        .toggle-switch:before { content: ''; position: absolute; width: 21px; height: 21px; border-radius: 50%; background: white; top: 2px; left: 2px; transition: transform 0.3s; }
        .toggle-switch.active:before { transform: translateX(25px); }
        .active-theme { font-weight: 900 !important; border: 2px solid var(--color-warning) !important; transform: translateY(-2px) !important; box-shadow: 0 6px var(--color-button-menu-shadow) !important; }
        #comboText { position: absolute; font-size: 2rem; font-weight: bold; color: var(--color-warning); text-shadow: 0 0 10px var(--color-warning); animation: flyup 1.5s ease-out forwards; pointer-events: none; z-index: 50; }
        @keyframes flyup { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-100px) scale(0.5); opacity: 0; } }

        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--color-main);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px; 
            transition: background 0.5s, color 0.5s;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 480px; 
            width: 100%;
            background: var(--ui-background);
            padding: 15px; 
            border-radius: 20px;
            box-shadow: 0 0 40px rgba(71, 107, 255, 0.4);
        }
        
        #gameCanvas {
            width: 100%; 
            height: auto; 
            aspect-ratio: 1 / 1; 
            box-shadow: 0 0 20px rgba(248, 248, 242, 0.2);
            border-radius: 10px;
            background-color: var(--color-canvas-bg);
            touch-action: none;
            transition: background 0.5s;
            border: none;
        }

        .header h1 {
            font-size: 2rem; 
            color: var(--color-accent);
            text-shadow: 0 0 10px var(--color-accent, 0.6);
        }

        #gameInfoBar {
            width: 100%;
            max-width: 100%; 
            padding: 10px 0;
            box-sizing: border-box;
        }
        
        .btn {
            padding: 10px 15px;
            border-radius: 8px;
            background-color: var(--color-button-primary);
            color: var(--color-main);
            font-weight: 700;
            box-shadow: 0 4px var(--color-button-primary-shadow);
            transition: all 0.15s ease-out;
        }

        .btn:hover {
            background-color: var(--color-button-primary-hover);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px var(--color-button-primary-shadow);
        }
        
        .btn-menu {
            background-color: var(--color-button-menu-bg);
            box-shadow: 0 4px var(--color-button-menu-shadow);
        }
        
        .btn-menu:hover {
            background-color: var(--color-button-menu-bg);
            filter: brightness(1.2);
        }
        .btn-menu:active {
             transform: translateY(2px);
             box-shadow: 0 2px var(--color-button-menu-shadow);
        }
        
        .modal-background {
            background-color: var(--ui-panel);
            border: 2px solid var(--color-accent);
        }

    </style>
</head>
<body class="theme-dark">

    <div id="gameContainer" class="game-container">
        <div class="header w-full">
            <h1>BLOCK LINK</h1>
        </div>
        
        <div class="game-area w-full flex-col items-center">
            
            <!-- In-Game Info Bar -->
            <div id="gameInfoBar" class="flex justify-between items-center" style="display: none;">
                <span class="text-xl font-bold">Score: <span id="currentScore">0</span></span>
                <!-- Gear Icon for Settings (Replaced Home Button) -->
                <button id="settingsBtn" class="btn btn-menu text-sm py-1 px-3">
                    <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings">
                        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 0-.74 2.8v.9a2 2 0 0 0-.25 1.11L2 12l.14.77a2 2 0 0 0 .25 1.11v.9a2 2 0 0 0 .74 2.8l.43.25a2 2 0 0 1 1 1.73v.18a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 0 .74-2.8v-.9a2 2 0 0 0 .25-1.11L22 12l-.14-.77a2 2 0 0 0-.25-1.11v-.9a2 2 0 0 0-.74-2.8l-.43-.25a2 2 0 0 1-1-1.73v-.18a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>
                    </svg>
                </button>
            </div>
            
            <!-- Main Canvas -->
            <canvas id="gameCanvas" style="display: none;"></canvas>
            
        </div>
    </div>

    <!-- Generic Game Modal for Menus and Game Over -->
    <div id="gameModal" class="fixed inset-0 flex justify-center items-center z-50 transition-opacity duration-300">
        <div id="modalContentContainer" class="modal-background p-8 rounded-xl shadow-2xl max-w-lg w-full">
            
            <!-- === Main Menu Content (Home Screen) === -->
            <div id="mainMenuContent" class="modal-screen">
                <h2 class="text-3xl font-bold mb-8 text-center">Block Link</h2>
                <div class="flex flex-col gap-4">
                    <button id="mainMenuPlayBtn" class="btn text-2xl py-4">Classic Mode</button>
                    <button id="mainMenuSettingsBtn" class="btn btn-menu text-xl py-4">Settings</button>
                </div>
                <!-- Displaying only the High Score -->
                <div class="text-sm text-center mt-6 opacity-75">
                    High Score: <span id="highScore">0</span>
                </div>
            </div>

            <!-- === Settings Content === -->
            <div id="settingsContent" class="modal-screen hidden">
                <h2 class="text-3xl font-bold mb-6 text-center">Settings</h2>
                
                <div class="flex flex-col gap-6 text-lg mb-8">
                    
                    <!-- Sound Toggle -->
                    <div class="flex justify-between items-center bg-black bg-opacity-20 p-3 rounded-lg">
                        <span>Sound Effects:</span>
                        <div id="soundToggle" class="toggle-switch"></div>
                    </div>

                    <!-- Vibration Toggle (Mobile Accessibility) -->
                    <div class="flex justify-between items-center bg-black bg-opacity-20 p-3 rounded-lg">
                        <span>Vibration Feedback:</span>
                        <div id="vibrationToggle" class="toggle-switch"></div>
                    </div>
                    
                    <!-- Back Home Button (for the initial request) -->
                    <button id="settingsBackHomeBtn" class="btn btn-menu w-full mt-2">Back to Home</button>

                    <!-- Theme Selection -->
                    <div class="flex flex-col">
                        <label class="font-bold mb-2 text-yellow-300">Color Theme:</label>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                            <button id="theme-dark-btn" class="btn btn-menu py-2 text-sm" data-theme="dark">Dark Mode</button>
                            <button id="theme-light-btn" class="btn btn-menu py-2 text-sm" data-theme="light">Light Mode</button>
                            <button id="theme-forest-btn" class="btn btn-menu py-2 text-sm" data-theme="forest">Forest</button>
                            <button id="theme-upside-down-btn" class="btn btn-menu py-2 text-sm" data-theme="upside-down">Upside Down</button>
                            <button id="theme-ocean-btn" class="btn btn-menu py-2 text-sm" data-theme="ocean">Ocean</button>
                        </div>
                    </div>
                    
                    <!-- Help Button -->
                    <button id="helpBtn" class="btn btn-menu">How to Play</button>
                    
                </div>
                
                <button id="settingsBackBtn" class="btn btn-menu w-full mt-4">Back to Home</button>
            </div>
            
            <!-- === Help Content Modal === -->
            <div id="helpContent" class="modal-screen hidden">
                <h2 class="text-3xl font-bold mb-6 text-center">How to Play</h2>
                <div class="text-sm space-y-4 opacity-80">
                    <p>The goal of Block Link is to clear colored blocks by linking them together.</p>
                    <ul class="list-disc list-inside space-y-2 ml-4">
                        <li><span class="font-bold text-yellow-300">Linking:</span> Tap or click a block and drag your finger/mouse across neighboring blocks of the *same color*.</li>
                        <li><span class="font-bold text-yellow-300">Movement:</span> Links must be horizontal or vertical (not diagonal).</li>
                        <li><span class="font-bold text-yellow-300">Clearing:</span> A link must contain a minimum of **3** blocks to clear.</li>
                        <li><span class="font-bold text-yellow-300">Gravity:</span> Cleared blocks disappear, and the blocks above fall down. New blocks fill in from the top.</li>
                        <li><span class="font-bold text-red-400">Game Over:</span> The game ends when there are no more possible links of 3 or more blocks remaining on the board.</li>
                    </ul>
                </div>
                <button id="helpBackBtn" class="btn btn-menu w-full mt-6">Got It!</button>
            </div>

            <!-- === Game Over Content === -->
            <div id="gameOverContent" class="modal-screen hidden">
                <h2 class="text-3xl font-bold text-red-400 mb-3 text-center">Game Over</h2>
                <p id="finalScoreText" class="text-lg mb-5 opacity-80"></p>
                <button id="gameOverPlayAgainBtn" class="btn w-full">Play Again</button>
                <button id="gameOverMenuBtn" class="btn btn-menu mt-2 w-full">Home</button>
            </div>

        </div>
    </div>

    <!-- Firebase Imports and Game Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Set Firebase Log Level
        setLogLevel('debug');

        // --- GLOBAL VARIABLES & CONSTANTS ---
        const GRID_SIZE = 8;
        let BLOCK_SIZE = 0; 
        let CANVAS_SIZE = 0; 
        
        const COLOR_MAP = [
            '#4A90E2', // Blue
            '#50E3C2', // Teal
            '#F5A623', // Orange
            '#D0021B', // Red
            '#9013FE', // Purple
            '#F8E71C'  // Yellow
        ];
        const MIN_PATH_LENGTH = 3;

        // Core Game State
        let board = [];
        let score = 0;
        let highScore = 0;
        let totalCleared = 0;
        let isGameOver = false;
        let isLinking = false;
        let selectedPath = []; 
        let selectedColorIndex = 0; 
        
        // Settings State
        let settings = {
            theme: 'dark',
            vibration: false,
            soundEnabled: true 
        };

        // Canvas & Contexts
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // DOM Elements
        const gameContainer = document.getElementById('gameContainer');
        const currentScoreDisplay = document.getElementById('currentScore');
        const highScoreDisplay = document.getElementById('highScore');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameInfoBar = document.getElementById('gameInfoBar');

        // Modal Elements
        const gameModal = document.getElementById('gameModal');
        const finalScoreText = document.getElementById('finalScoreText');
        const vibrationToggle = document.getElementById('vibrationToggle');
        const soundToggle = document.getElementById('soundToggle');
        const body = document.body;

        const modalScreens = {
            main: document.getElementById('mainMenuContent'),
            settings: document.getElementById('settingsContent'),
            game_over: document.getElementById('gameOverContent'),
            help: document.getElementById('helpContent')
        };


        // --- FIREBASE & AUTH SETUP ---
        let db, auth;
        let userId = 'anon';
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const HIGH_SCORE_PATH = `/artifacts/${appId}/public/data/highscores/global`;

        // Tone.js Audio Setup
        let selectSynth, clearSynth;

        function setupAudio() {
            selectSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 5000, resonance: 0.7 }).toDestination();
            clearSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.005, decay: 0.2, sustain: 0.05, release: 0.5 }
            }).toDestination();
        }

        function playSelectSound() {
            if (!settings.soundEnabled) return; 
            if (Tone.context.state === 'running') { selectSynth.triggerAttackRelease("C5", "16n", Tone.now(), 0.6); }
        }

        function playClearSound(count) {
            if (!settings.soundEnabled) return;
            if (Tone.context.state !== 'running') return;
            
            const root = count >= 5 ? "C4" : (count >= 4 ? "D4" : "E4");
            const pattern = [root, Tone.Midi(Tone.Frequency(root).toMidi() + 4).toNote(), Tone.Midi(Tone.Frequency(root).toMidi() + 7).toNote(), Tone.Midi(Tone.Frequency(root).toMidi() + 12).toNote()];
            const notes = pattern.slice(0, Math.min(count - 1, pattern.length));

            let time = Tone.now();
            notes.forEach((note, index) => {
                clearSynth.triggerAttackRelease(note, "16n", time + index * 0.06);
            });
        }
        
        setupAudio();

        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        listenForHighScores();
                        loadSettings();
                        showScreen('main'); 
                    } else {
                        highScoreDisplay.textContent = 'N/A';
                        loadSettings();
                        showScreen('main'); 
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                highScoreDisplay.textContent = 'N/A';
                loadSettings();
                showScreen('main'); 
            }
        }

        // --- FIREBASE DATA FUNCTIONS ---
        function listenForHighScores() {
            if (!db) return;
            const docRef = doc(db, HIGH_SCORE_PATH);
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    highScore = data.highScore || 0;
                    highScoreDisplay.textContent = highScore.toLocaleString();
                }
            }, (error) => {
                console.error("Error listening to high score:", error);
            });
        }

        async function updateHighScore() {
            if (!db || !userId) return;

            if (score > highScore) {
                highScore = score;
                highScoreDisplay.textContent = highScore.toLocaleString();
                
                const docRef = doc(db, HIGH_SCORE_PATH);
                const newScoreData = {
                    highScore: highScore,
                    userId: userId,
                    timestamp: new Date()
                };

                try {
                    await setDoc(docRef, newScoreData, { merge: true });
                    console.log("High score updated successfully:", highScore);
                } catch (e) {
                    console.error("Error updating high score:", e);
                }
            }
        }
        
        // --- SETTINGS MANAGEMENT ---
        function saveSettings() {
            try { localStorage.setItem('blockLinkSettings', JSON.stringify(settings)); } catch (e) { console.error("Could not save settings to localStorage:", e); }
        }

        function loadSettings() {
            try {
                const storedSettings = localStorage.getItem('blockLinkSettings');
                if (storedSettings) { settings = JSON.parse(storedSettings); }
            } catch (e) { console.error("Could not load settings from localStorage:", e); }

            if (typeof settings.soundEnabled === 'undefined') { settings.soundEnabled = true; }
            if (typeof settings.vibration === 'undefined') { settings.vibration = false; }
            if (typeof settings.theme === 'undefined') { settings.theme = 'dark'; }

            applyTheme(settings.theme);
            updateVibrationToggleUI(settings.vibration);
            updateSoundToggleUI(settings.soundEnabled); 
        }
        
        function updateSoundToggleUI(isActive) {
            if (isActive) { soundToggle.classList.add('active'); } else { soundToggle.classList.remove('active'); }
        }

        function toggleSound() {
            settings.soundEnabled = !settings.soundEnabled;
            updateSoundToggleUI(settings.soundEnabled);
            saveSettings();
        }

        function applyTheme(themeName) {
            body.className = '';
            body.classList.add(`theme-${themeName}`);
            settings.theme = themeName;
            saveSettings();
            
            document.querySelectorAll('#settingsContent .btn[data-theme]').forEach(btn => {
                btn.classList.remove('active-theme');
                if (btn.dataset.theme === themeName) {
                    btn.classList.add('active-theme');
                }
            });
        }
        
        function updateVibrationToggleUI(isActive) {
            if (isActive) { vibrationToggle.classList.add('active'); } else { vibrationToggle.classList.remove('active'); }
        }

        function toggleVibration() {
            settings.vibration = !settings.vibration;
            updateVibrationToggleUI(settings.vibration);
            saveSettings();
            if (settings.vibration) { triggerVibration(20); }
        }

        function triggerVibration(duration = 100) {
            if (settings.vibration && 'vibrate' in navigator) {
                navigator.vibrate(duration);
            }
        }

        // --- UI & GAME FLOW CONTROL ---
        function showScreen(screenName) {
            // Hide all screens
            Object.values(modalScreens).forEach(el => el.classList.add('hidden'));

            if (screenName !== 'game') {
                // Show modal overlay
                gameModal.style.visibility = 'visible';
                gameModal.style.opacity = '0';
                setTimeout(() => gameModal.style.opacity = '1', 10);
                gameCanvas.style.display = 'none';
                gameInfoBar.style.display = 'none';
                
                // Show requested screen content
                const screenEl = modalScreens[screenName];
                if (screenEl) { screenEl.classList.remove('hidden'); }
            } else {
                // Hide modal and start game
                gameModal.style.opacity = '0';
                setTimeout(() => { gameModal.style.visibility = 'hidden'; }, 300);
                gameCanvas.style.display = 'block';
                gameInfoBar.style.display = 'flex';
                // Initialize/reset game on play
                initGame(); 
            }
        }


        // --- DYNAMIC DIMENSION CALCULATION ---
        function calculateDimensions() {
            // Get the current width of the game container, excluding padding
            const containerWidth = gameContainer.clientWidth - 30; 
            
            // CANVAS_SIZE will be the largest square that fits, using the container width
            const size = containerWidth; 
            
            BLOCK_SIZE = Math.floor(size / GRID_SIZE);
            CANVAS_SIZE = BLOCK_SIZE * GRID_SIZE;
            
            // Set canvas element attributes for drawing resolution
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            
            // Set max-width of info bar to match the canvas
            gameInfoBar.style.maxWidth = `${CANVAS_SIZE}px`;
            
            // When Tone.js is ready and game is active, start audio context
            if (Tone.context.state !== 'running') {
                 Tone.start().then(() => { console.log("Audio context started."); });
            }
        }

        // --- GAME LOGIC FUNCTIONS ---

        function initGame() {
            // 1. Calculate the dynamic dimensions based on viewport/container size
            calculateDimensions(); 
            
            score = 0;
            totalCleared = 0;
            isGameOver = false;
            selectedPath = [];
            isLinking = false;
            
            // Fill the board randomly
            board = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill(0).map(() => Math.floor(Math.random() * COLOR_MAP.length) + 1)
            );
            
            // Ensure the board is solvable initially (optional, but good practice)
            while (!checkPossibleMoves()) {
                 board = Array(GRID_SIZE).fill(0).map(() => 
                    Array(GRID_SIZE).fill(0).map(() => Math.floor(Math.random() * COLOR_MAP.length) + 1)
                );
            }

            updateScoreDisplay();
            drawGame();
        }

        function endGame() {
             isGameOver = true;
             updateHighScore();
             finalScoreText.textContent = `Your Score: ${score.toLocaleString()} | High Score: ${highScore.toLocaleString()}`;
             showScreen('game_over');
        }
        
        function checkPossibleMoves() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const color = board[y][x];
                    if (color === 0) continue;

                    // Check horizontal links (need 3 total, so check up to x+2)
                    if (x + 2 < GRID_SIZE && board[y][x + 1] === color && board[y][x + 2] === color) { return true; }

                    // Check vertical links (need 3 total, so check up to y+2)
                    if (y + 2 < GRID_SIZE && board[y + 1][x] === color && board[y + 2][x] === color) { return true; }
                }
            }
            return false;
        }

        function updateScoreDisplay() {
             currentScoreDisplay.textContent = score.toLocaleString();
        }

        function getGridCoordinates(canvasX, canvasY) {
            const gridX = Math.floor(canvasX / BLOCK_SIZE);
            const gridY = Math.floor(canvasY / BLOCK_SIZE);

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                return { x: gridX, y: gridY };
            }
            return null;
        }
        
        function isAdjacent(x1, y1, x2, y2) {
            return (Math.abs(x1 - x2) + Math.abs(y1 - y2) === 1); // Manhattan distance of 1
        }
        
        // --- Input Handler (BUG FIX HERE) ---
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Calculate raw coordinates relative to the visible element
            const rawX = clientX - rect.left;
            const rawY = clientY - rect.top;

            // BUG FIX: Scale the raw coordinates based on the difference between 
            // the CSS display size (rect.width/height) and the internal drawing size (CANVAS_SIZE)
            const scaleX = CANVAS_SIZE / rect.width;
            const scaleY = CANVAS_SIZE / rect.height;

            return {
                x: rawX * scaleX,
                y: rawY * scaleY
            };
        }

        function onLinkStart(e) {
            if (isGameOver || gameCanvas.style.display === 'none') return;
            e.preventDefault();

            // IMPORTANT: Recalculate dimensions on start, which also handles audio context
            calculateDimensions(); 

            const pos = getCanvasCoordinates(e); 
            const coords = getGridCoordinates(pos.x, pos.y);

            if (coords) {
                const colorIndex = board[coords.y][coords.x];
                if (colorIndex !== 0) {
                    isLinking = true;
                    selectedColorIndex = colorIndex;
                    selectedPath = [{ x: coords.x, y: coords.y }];
                    drawGame();
                }
            }
        }
        
        function onLinkMove(e) { 
            if (!isLinking || isGameOver) return;
            e.preventDefault();

            const pos = getCanvasCoordinates(e); 
            const coords = getGridCoordinates(pos.x, pos.y);

            if (coords) {
                const { x, y } = coords;
                const colorIndex = board[y][x];
                const lastCell = selectedPath[selectedPath.length - 1];

                if (colorIndex !== selectedColorIndex) { return; }
                if (!isAdjacent(lastCell.x, lastCell.y, x, y)) { return; }

                const existingIndex = selectedPath.findIndex(p => p.x === x && p.y === y);

                if (existingIndex !== -1) {
                    if (existingIndex === selectedPath.length - 2) {
                        selectedPath.pop();
                        playSelectSound();
                    }
                } else {
                    selectedPath.push({ x, y });
                    playSelectSound();
                }

                drawGame();
            }
        }

        function onLinkEnd(e) {
            if (!isLinking || isGameOver) return;
            e.preventDefault();

            isLinking = false;
            
            if (selectedPath.length >= MIN_PATH_LENGTH) {
                clearAndRefill();
            } else {
                selectedPath = [];
                drawGame();
            }
        }

        async function clearAndRefill() {
            const clearedCount = selectedPath.length;
            score += clearedCount * 10 * clearedCount; 
            totalCleared += clearedCount;
            updateScoreDisplay();
            showComboText(clearedCount);
            triggerVibration(50);
            playClearSound(clearedCount);

            selectedPath.forEach(({ x, y }) => { board[y][x] = 0; });
            selectedPath = [];
            drawGame();
            
            // Pause to show the clearance effect
            await new Promise(resolve => setTimeout(resolve, 150)); 

            applyGravity();
            drawGame();
            
            // Refill new blocks
            refillNewBlocks();
            drawGame();

            if (!checkPossibleMoves()) { endGame(); }
        }

        function applyGravity() {
            for (let x = 0; x < GRID_SIZE; x++) {
                let emptySlots = 0;
                for (let y = GRID_SIZE - 1; y >= 0; y--) {
                    if (board[y][x] === 0) {
                        emptySlots++;
                    } else if (emptySlots > 0) {
                        // Move block down
                        board[y + emptySlots][x] = board[y][x];
                        board[y][x] = 0;
                    }
                }
            }
        }

        function refillNewBlocks() {
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    if (board[y][x] === 0) {
                        // Generate a random color index (1 to COLOR_MAP.length)
                        board[y][x] = Math.floor(Math.random() * COLOR_MAP.length) + 1; 
                    }
                }
            }
        }
        
        function showComboText(count) {
             const comboText = document.createElement('div');
             comboText.id = 'comboText';
             comboText.textContent = `${count}x Combo!`;
             
             // Get canvas position relative to viewport
             const rect = canvas.getBoundingClientRect();
             comboText.style.left = `${rect.left + rect.width / 2}px`;
             comboText.style.top = `${rect.top + rect.height / 2}px`;
             comboText.style.transform = `translate(-50%, -50%)`;
             
             document.body.appendChild(comboText);

             setTimeout(() => {
                 comboText.remove();
             }, 1500); 
        }

        // --- RENDERING FUNCTIONS ---
        function drawBlockCell(ctx, x, y, colorIndex, isSelected = false) {
            if (colorIndex === 0 || BLOCK_SIZE === 0) return;
            const color = COLOR_MAP[colorIndex - 1];
            
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = color;
            ctx.strokeStyle = 'transparent';
            ctx.lineWidth = 0;
            ctx.shadowBlur = 0;

            const padding = BLOCK_SIZE * 0.08; 
            const drawSize = BLOCK_SIZE - 2 * padding;
            const drawX = x * BLOCK_SIZE + padding;
            const drawY = y * BLOCK_SIZE + padding;
            const radius = BLOCK_SIZE * 0.13; 
            
            if (isSelected) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.strokeStyle = 'var(--color-canvas-bg)';
                ctx.lineWidth = 4; 
            }

            // Draw a rounded rectangle block
            ctx.beginPath();
            ctx.moveTo(drawX + radius, drawY);
            ctx.lineTo(drawX + drawSize - radius, drawY);
            ctx.arc(drawX + drawSize - radius, drawY + radius, radius, 1.5 * Math.PI, 2 * Math.PI);
            ctx.lineTo(drawX + drawSize, drawY + drawSize - radius);
            ctx.arc(drawX + drawSize - radius, drawY + drawSize - radius, radius, 0, 0.5 * Math.PI);
            ctx.lineTo(drawX + radius, drawY + drawSize);
            ctx.arc(drawX + radius, drawY + drawSize - radius, radius, 0.5 * Math.PI, Math.PI);
            ctx.lineTo(drawX, drawY + radius);
            ctx.arc(drawX + radius, drawY + radius, radius, Math.PI, 1.5 * Math.PI);
            ctx.closePath();
            
            ctx.fill();
            
            if (isSelected) { ctx.stroke(); }
            
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1;
        }

        function drawGrid() {
            if (CANVAS_SIZE === 0) return; 
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            // Draw grid lines (optional, can be hidden for a cleaner look)
            ctx.strokeStyle = 'var(--color-grid-line)';
            ctx.lineWidth = 1;
            for (let i = 1; i < GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, CANVAS_SIZE);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(CANVAS_SIZE, i * BLOCK_SIZE);
                ctx.stroke();
            }

            // Draw blocks
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const isCellSelected = selectedPath.some(p => p.x === x && p.y === y);
                    drawBlockCell(ctx, x, y, board[y][x], isCellSelected);
                }
            }
        }

        function drawSelectionPath() {
            if (selectedPath.length < 2 || BLOCK_SIZE === 0) return;

            ctx.lineWidth = 10;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = COLOR_MAP[selectedColorIndex - 1];
            ctx.shadowColor = ctx.strokeStyle;
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            
            const center = (x, y) => ({
                cx: x * BLOCK_SIZE + BLOCK_SIZE / 2,
                cy: y * BLOCK_SIZE + BLOCK_SIZE / 2,
            });

            const start = center(selectedPath[0].x, selectedPath[0].y);
            ctx.moveTo(start.cx, start.cy);

            for (let i = 1; i < selectedPath.length; i++) {
                const next = center(selectedPath[i].x, selectedPath[i].y);
                ctx.lineTo(next.cx, next.cy);
            }

            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw small dot/circle on the last selected cell for highlight
             const last = center(selectedPath[selectedPath.length - 1].x, selectedPath[selectedPath.length - 1].y);
             ctx.fillStyle = 'white';
             ctx.beginPath();
             ctx.arc(last.cx, last.cy, 5, 0, Math.PI * 2);
             ctx.fill();
        }

        function drawGame() {
            drawGrid();
            drawSelectionPath();
        }

        // --- EVENT LISTENERS ---

        function handleResize() {
            // Recalculate dimensions on resize
            calculateDimensions();
            // Redraw only if the canvas is visible (i.e., game is running)
            if (gameCanvas.style.display !== 'none') {
                drawGame();
            }
        }

        function addEventListeners() {
            // Game Input Events
            canvas.addEventListener('mousedown', onLinkStart);
            window.addEventListener('mousemove', onLinkMove);
            window.addEventListener('mouseup', onLinkEnd);
            canvas.addEventListener('touchstart', onLinkStart);
            window.addEventListener('touchmove', onLinkMove);
            canvas.addEventListener('touchend', onLinkEnd);

            // Responsive Event
            window.addEventListener('resize', handleResize);

            // Menu Navigation Listeners
            document.getElementById('mainMenuPlayBtn').addEventListener('click', () => showScreen('game'));
            document.getElementById('mainMenuSettingsBtn').addEventListener('click', () => showScreen('settings'));
            document.getElementById('settingsBtn').addEventListener('click', () => showScreen('settings')); 
            document.getElementById('settingsBackBtn').addEventListener('click', () => showScreen('main'));
            document.getElementById('settingsBackHomeBtn').addEventListener('click', () => showScreen('main')); // Back home button in settings
            document.getElementById('gameOverPlayAgainBtn').addEventListener('click', () => showScreen('game'));
            document.getElementById('gameOverMenuBtn').addEventListener('click', () => showScreen('main'));
            
            // Settings Controls
            document.getElementById('helpBtn').addEventListener('click', () => showScreen('help'));
            document.getElementById('helpBackBtn').addEventListener('click', () => showScreen('settings'));

            // Theme Buttons
            document.getElementById('theme-dark-btn').addEventListener('click', () => applyTheme('dark'));
            document.getElementById('theme-light-btn').addEventListener('click', () => applyTheme('light'));
            document.getElementById('theme-forest-btn').addEventListener('click', () => applyTheme('forest'));
            document.getElementById('theme-upside-down-btn').addEventListener('click', () => applyTheme('upside-down'));
            document.getElementById('theme-ocean-btn').addEventListener('click', () => applyTheme('ocean'));

            // Toggle Controls
            vibrationToggle.addEventListener('click', toggleVibration);
            soundToggle.addEventListener('click', toggleSound);
        }

        // --- GAME START ---
        
        initializeFirebase();
        addEventListeners();

    </script>
</body>
</html>